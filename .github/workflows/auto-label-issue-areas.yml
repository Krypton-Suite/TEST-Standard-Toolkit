name: Auto-label issue areas

on:
  issues:
    types:
      - opened
      - edited

permissions:
  issues: write

jobs:
  label-areas:
    runs-on: ubuntu-latest
    steps:
      - name: Extract and apply area labels
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const issueTitle = issue.title || '';
            
            // Extract labels once for reuse
            const labels = (issue.labels || []).map(
              label => typeof label === 'string' ? label : label.name
            );
            
            // Auto-prefix issue titles based on template type
            // Only do this for newly opened issues (not edits)
            if (context.payload.action === 'opened') {
              
              let titlePrefix = null;
              
              // Check for Bug Report template
              const hasBugLabel = labels.includes('bug');
              const hasBugReportFields = issueBody.includes('### Steps to Reproduce');
              if ((hasBugLabel || hasBugReportFields) && !issueTitle.startsWith('[Bug]: ')) {
                titlePrefix = '[Bug]: ';
              }
              // Check for Feature Request template
              else if ((labels.includes('enhancement') || labels.includes('new feature') || labels.includes('suggestion') || 
                       issueBody.includes('### Feature Description')) && 
                       !issueTitle.startsWith('[Feature Request]: ')) {
                titlePrefix = '[Feature Request]: ';
              }
              // Check for Other Issues template
              else if ((labels.includes('discussion') || labels.includes('other') || 
                       issueBody.includes('### Please describe your issue')) && 
                       !issueTitle.startsWith('[Other Issues]: ')) {
                titlePrefix = '[Other Issues]: ';
              }
              // Check for Post a Question template
              else if ((labels.includes('question') || 
                       issueBody.includes('### What do you want to ask?')) && 
                       !issueTitle.startsWith('[Question]: ')) {
                titlePrefix = '[Question]: ';
              }
              
              if (titlePrefix) {
                const newTitle = `${titlePrefix}${issueTitle}`;
                try {
                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: issue.number,
                    title: newTitle,
                  });
                  console.log(`Updated issue title to: ${newTitle}`);
                } catch (error) {
                  console.warn(`Failed to update issue title: ${error.message}`);
                }
              }
            }
            
            // Map area names to label names
            const areaToLabel = {
              'Docking': 'area:docking',
              'Navigator': 'area:navigator',
              'Ribbon': 'area:ribbon',
              'Toolkit': 'area:toolkit',
              'Workspace': 'area:workspace'
            };
            
            // Extract "Areas Affected" field from issue body (only for bug reports)
            // GitHub issue forms store dropdown selections as markdown lists
            // Pattern matches: ### Areas Affected followed by bulleted list items
            const isBugReport = labels.includes('bug') || issueBody.includes('### Steps to Reproduce');
            
            if (!isBugReport) {
              console.log('Not a bug report - skipping area label assignment.');
              return;
            }
            
            const areasAffectedMatch = issueBody.match(/###\s+Areas Affected\s*\n+([\s\S]*?)(?=\n###|\n*$)/i);
            
            if (!areasAffectedMatch) {
              console.log('No "Areas Affected" field found in issue body.');
              return;
            }
            
            const areasText = areasAffectedMatch[1].trim();
            // Extract bullet list items (lines starting with - or *)
            const selectedAreas = areasText.split('\n')
              .map(line => line.replace(/^[-*]\s+/, '').trim())
              .filter(area => area.length > 0 && !area.match(/^<!--/)); // Filter out HTML comments
            
            if (!selectedAreas.length) {
              console.log('No areas selected.');
              return;
            }
            
            console.log(`Found selected areas: ${selectedAreas.join(', ')}`);
            
            // Map areas to labels
            const labelsToAdd = selectedAreas
              .map(area => areaToLabel[area] || area)
              .filter(label => label); // Remove any undefined/null values
            
            if (!labelsToAdd.length) {
              console.log('No valid labels to add.');
              return;
            }
            
            // Get existing labels on the issue (reuse already extracted labels)
            const existingLabels = labels;
            
            // Only add labels that aren't already present
            const newLabels = labelsToAdd.filter(label => !existingLabels.includes(label));
            
            if (!newLabels.length) {
              console.log('All area labels are already present on the issue.');
              return;
            }
            
            console.log(`Adding labels: ${newLabels.join(', ')}`);
            
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issue.number,
                labels: newLabels,
              });
              console.log(`Successfully added ${newLabels.length} label(s) to issue #${issue.number}`);
            } catch (error) {
              console.error(`Failed to add labels: ${error.message}`);
              // If some labels don't exist, try adding them one by one
              for (const label of newLabels) {
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: issue.number,
                    labels: [label],
                  });
                  console.log(`Added label: ${label}`);
                } catch (labelError) {
                  console.warn(`Failed to add label "${label}": ${labelError.message}`);
                }
              }
            }

